---
alwaysApply: false
---
# Task Execution Protocol
Execute backlog tasks ‚Üí update after each ‚Üí stop at boundaries

## Input Formats
- Task: `[1.1]` or `[2.3], [2.4], [2.5]`
- Phase: `Phase 2` or `Phase 2 and 3`
- All: `complete backlog` / `all`
- Continue: `continue` / `next`

## Execution Flow
1. Load backlog from .cursor/memory/ (`YYYYMMDD-VV-backlog-*.md`)
2. Parse scope (task/phase/all)
3. Check dependencies & blockers
4. For each task:
   - Read "What to do"
   - Execute (apply KISS)
   - Update: ‚è≥ ‚Üí ‚úÖ, add date + "Work done"
   - Recalc progress %
   - Update backlog in .cursor/memory/
5. Stop at boundary + report

## Stop Conditions
- Scope complete ‚Üí STOP
- Blocker (‚ö†Ô∏è) ‚Üí STOP + explain
- Unclear ‚Üí STOP + ask
- User interrupt ‚Üí STOP + save

## Update Format
Follow backlog template exactly:
- "What to do:" (unchanged)
- "Date completed:" YYYY-MM-DD
- "Work done:" [detailed actions]
- Status: ‚è≥ | üîÑ | ‚úÖ | ‚ö†Ô∏è

## Completion Report
```
‚úÖ Execution Complete
Scope: [what executed]
Tasks: X completed
Progress: XX% ‚Üí YY%
Next: [Phase.Task#] [description]
Backlog: @memory/[file].md
```